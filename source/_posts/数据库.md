---
title: 数据库知识
categories:
    - 数据库
tags:
    - 数据库
---

## 事务
1. 事务的几个特性：
    - 原子性：数据库中与原子性相关的操作有rollback和commit。commit用于正常提交一个事务，rollback用于将事务中之前的操作回滚。第三种情况是数据库出现异常时，如断电，事务执行一半而退出。 事务的整个执行过程说明如下： （1） 每个事务开始时，系统会为该事务分配一个时间戳（唯一标识该事务）、回滚段和undo段。 （2） 事务中的每条SQL在执行修改操作前都会写undo日志，然后再将更新的内容写入undo段。 （3） 执行commit时，系统将修改的数据写入实际内存，并将修改信息写入回滚段。 （4） 执行rollback时，系统将undo段内容失效。 （5） 当系统在执行事务过程中出现异常退出后，系统再次启动，会从undo日志中恢复。
    - 隔离性：
        - 悲观控制：数据的删改查操作都会对数据加锁，直到事务操作完成才允许其他事务对数据进行操作。依靠数据库提供的锁操作。主要用于数据竞争激烈的环境以及锁保护的成本低于回滚成本的环境中。但是并发处理能力非常低，不适用于海量数据
        - 乐观控制：它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。
    - 持久性：需要日志的支持。原则是执行写数据前需要先写日志
    - 一致性：前提是事务的原子性和隔离性
2. 事务的推荐用法：
    - 开启新事务前先rollback一下
    - 每次做完update后校验affected_rows是否是期望的
    - 考虑重连逻辑
    - 尽量避免大事务
    - 加锁资源使用要有一定的顺序， 避免死锁
    - mysql的事务尽量小，使用完，立即commit或rollback.不要起一个过大的事务
    - 避免尝试去锁一个不存在的记录，for update语句where条件请使用主键
    - 避免过多的for update集合
    - mysql单表记录保持在1000W以下，以获得较好的性能
    - 需要修改mysql 锁等待时间，避免for update等待时间超长，造成系统阻塞。innodb_lock_wait_timeout 参数

## 锁
1. MySQL实现的两种锁：
    - 共享锁：允许其他事务读数据，阻止其他事务获取相同数据集的排它锁
    - 排它锁：独占数据，阻止其他事务获取相同数据集的共享锁和排它锁(对update，delete，insert语句会自动添加排它锁)
2. 对于普通的select语句，数据库不会主动添加任何锁，需要主动添加锁
    >共享锁：...lock in share mode
    >排它锁：...for update
3. 死锁：
    - 条件：互斥，请求与保持，不剥夺，循环等待
